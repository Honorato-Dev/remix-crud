.  criar projeto remix: npx create-remix@latest

.  add nome do projeto, express, typescript

.  add o repositorio remoto

. instalar o triology e sql.js: npm install trilogy sql.js

.  criar na raiz lib.db.server.ts. OBS: o Remix sabe que arquivos .server não irão pra o frontend

. Em routes/index.tsx importar getModels de db.server.tsx, criar LoaderFunction do remix pra manipular os dados e tranformar em json()

. No Index retornar os dados com useLoaderdata() em seguida passar a variavel estanciada com .map()

OBS: npm run dev

CREATE 
. No Index.tsx import o Form d remix/react add <Form method="post" action="?index">com <input> de author e quote, criar tambem o <button>
.  import ActioFunction e usar async com parametro  request e usar.formData.get() pra pegar o author e o quote 

.  typar o quote criando uma interface no main index.tsx, passando a tipagem dos getModels

DELETE  

with JS
. add um <Form> com o metodo delete,criar no <Form> delete um <input> type hidden com o name="id" e o value={quote.id.toString()}, em seguida criar uma condicinal  pra o request.method se for chamado  o DELETE : passar o ID estanciado o formData('id') e dar um await em Quote.remove({id})

without JS
.  pra que o delete funcione sem  javascript: mo <Form> passar o methot "POST" e criar um <input> type=hidden com o name "action" e o value:"delete", estanciar o formData('action') no action e passar o action no lugar do request.method na condicional "DELETE"

UPDATE 

.  em routes criar quote/$id.tsx. Lembrando que o  '$' é passado pra manipular dados pela URL, criar um <Form>,
criar LoaderFunction abstraindo params e estanciando em id o params.id 

OBS: em index.tsx passar o Link no <Form> <Link to={`/quote/${quote.id}`}>

.  importar o getModels de lib/db.server, abstrair o Quote e utilizar o metodo finfOne({id})

.  Abstrair {quote} de useLoaderData() em QuoteEdit, em seguida deixar predefinido nos campos do <input> o os valores atuais:  defaultValue= {quote.quote} e {quote.author} 

.  passar o action: ActionFunction com o request, params com eles usar o formData() pra capturar o quote e o author e usar o metodo update, e n final dar um retunr redirect("/") 


VALIDAÇÃO 01

.  instalar o ZOD: npm install zod

.  Em $id.tsx import {z} from 'zod'

.  criar QuoteSchema chamando z.object({}) e dentro dele passar as condições da validação dos campos, no caso desse projeto de quotes e de author 

.  ainda em $id.tsx dentro da action: estanciar o QuoteSchema.parse({}) em quoteObj, pra tornar o quote e o author um só objeto

.  passar em update o objeto quoteObj ja validado

.  em action dar um try{}catch(){} 

.  no catch estanciar errorr.issues e dar um reduce() em seguida retoonrar um json()

.  No componente QuoteEdit() importar o useActionData em seguida passar dentro do TSX um <pre>{JSON.stringify(action, null, 2)}</pre> pra visualisar os error no browser 

.  pra renderizar a mensagem de error na tela passar no TSX em baixo de cada <input>:     {action?.errors?.quote && <p>{action?.errors?.quote}</p>}
 

 VALIDAÇÃO 02

 .  tirar o o try/catch

 . substituir parse() por safeParse()

. depois do quoteObj criar condiconal: se quoteObj for success... acionar Quote.update() dentro da condicional, se não for, ele vai pra o próximo bloco que trata o error mostrando o que deve ser feito na tela

. usar o QuoteSchema  como modelo de tipagem: type Quote = z.infer<typeof QuoteSchema>

. depois usar Quote como interface de tipo pra quote ue é a estancia de useLoaderData():  const {quote} = useLoaderData() as { quote : Quote }

. passar mensagem de retorno de error em quoteObj() de acordo com o error apresentado

. passar no return json   errors:  quoteObj.error.flatten()

. criar um <LoaderDataType> type como uma interface e passar em useLoaderData

. criar uma nova interface de tipagem: inferSafeParserErrors<com genericos>

. criar um type ActionDtaType baseado no inferSafeParserErrors e usar em useActionData 




ORGANIZANDO

. criar models/Quote.ts e colocar as tipagem lá em seguida importar de volta pra $id.tsx

INDEX.TSX
.passar validation CREATE, passar o  safeParse() e a condicional  pra mostrar erro ou pra criar

.estanciar o useActionData()

.criar o: type ActionDataType, e importar o errors: QuoteErrors, e tipar o useActionData<ActionDataType>()





USETRANSITION

.Em index.tsx importar e estanciar  o useTransition() pra verificar as operações em andamento

. verificar o que tem no transition?:<pre>{JSON.stringify(transition,null,2)}</pre>

.criar a função sleep com setTimeout e passar no componente index o sleep(3000) pra testar o transition a seguir...

. criar no TSX uma condicioanal: {transition.state === "submiting" && <p>Salvando...</p>} pra aparecer a mensagem enquanto carregar os dados

. criar tambem o disabled no <button disabled={transition.state === "submitting"}> com a condicional pra desbilitar o button em quanto estiver carregando, e tambem uma condicional dentro do boão pra mostrar salvando... ou create Quote

.passar um <input hidden value 'create'> dentro do Form 

.criar o isSaving pra condicionar a renderização da menssagem de Loading de acorod com o processo de criar ou excluir


USEMATCHES

. criar routes/quotes.tsx, que estará no mesmo nível da past quotes, sendo assim o remix entende que ele se´ra o layout de tudo que tiver na pasta quotes

. em quotes.tsx importar e aplicar o <Outlet/>

.em quotes.tsx aplicar o hook useMatches() estaqnciado em matches

. criar e exportar objeto handle com o breadcrumb dentro dele retornando um <Link>

. em quotes.tsx no TSX dar um matches.map e criar uma condicional se o handle for true retonar o conteúdo de breadcrumb, que nsse caso é o <link>

. criar em index.tsx um objeto handle 'home' com o <Link to='/'>

.criar tambem no root.tsx
