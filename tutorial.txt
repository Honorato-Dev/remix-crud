1: criar projeto remix: npx create-remix@latest

2: add nome do projeto, express, typescript

3: add o repositorio remoto

4:instalar o triology e sql.js: npm install trilogy sql.js

5: criar na raiz lib.db.server.ts. OBS: o Remix sabe que arquivos .server não irão pra o frontend

6:Em routes/index.tsx importar getModels de db.server.tsx, criar LoaderFunction do remix pra manipular os dados e tranformar em json()

7:No Index retornar os dados com useLoaderdata() em seguida passar a variavel estanciada com .map()

OBS: npm run dev

CREATE 

8:No Index.tsx import o Form d remix/react add <Form method="post" action="?index">com <input> de author e quote, criar tambem o <button>

9: import ActioFunction e usar async com parametro  request e usar.formData.get() pra pegar o author e o quote 

10: typar o quote criando uma interface no main index.tsx, passando a tipagem dos getModels

DELETE  

with JS
11:add um <Form> com o metodo delete,criar no <Form> delete um <input> type hidden com o name="id" e o value={quote.id.toString()}, em seguida criar uma condicinal  pra o request.method se for chamado  o DELETE : passar o ID estanciado o formData('id') e dar um await em Quote.remove({id})

without JS
12: pra que o delete funcione sem  javascript: mo <Form> passar o methot "POST" e criar um <input> type=hidden com o name "action" e o value:"delete", estanciar o formData('action') no action e passar o action no lugar do request.method na condicional "DELETE"

UPDATE 

13: em routes criar quote/$id.tsx. Lembrando que o  '$' é passado pra manipular dados pela URL, criar um <Form>,
criar LoaderFunction abstraindo params e estanciando em id o params.id 

OBS: em index.tsx passar o Link no <Form> <Link to={`/quote/${quote.id}`}>

14: importar o getModels de lib/db.server, abstrair o Quote e utilizar o metodo finfOne({id})

15: Abstrair {quote} de useLoaderData() em QuoteEdit, em seguida deixar predefinido nos campos do <input> o os valores atuais:  defaultValue= {quote.quote} e {quote.author} 

16: passar o action: ActionFunction com o request, params com eles usar o formData() pra capturar o quote e o author e usar o metodo update, e n final dar um retunr redirect("/") 


VALIDAÇÃO 01

17: instalar o ZOD: npm install zod

18: Em $id.tsx import {z} from 'zod'

19: criar QuoteSchema chamando z.object({}) e dentro dele passar as condições da validação dos campos, no caso desse projeto de quotes e de author 

20: ainda em $id.tsx dentro da action: estanciar o QuoteSchema.parse({}) em quoteObj, pra tornar o quote e o author um só objeto

21: passar em update o objeto quoteObj ja validado

22: em action dar um try{}catch(){} 

23: no catch estanciar errorr.issues e dar um reduce() em seguida retoonrar um json()

24: No componente QuoteEdit() importar o useActionData em seguida passar dentro do TSX um <pre>{JSON.stringify(action, null, 2)}</pre> pra visualisar os error no browser 

25: pra renderizar a mensagem de error na tela passar no TSX em baixo de cada <input>:     {action?.errors?.quote && <p>{action?.errors?.quote}</p>}
 

 VALIDAÇÃO 02

 26: tirar o o try/catch

 . substituir parse() por safeParse()

. depois do quoteObj criar condiconal: se quoteObj for success... acionar Quote.update() dentro da condicional, se não for, ele vai pra o próximo bloco que trata o error mostrando o que deve ser feito na tela

. usar o QuoteSchema  como modelo de tipagem: type Quote = z.infer<typeof QuoteSchema>

. depois usar Quote como interface de tipo pra quote ue é a estancia de useLoaderData():  const {quote} = useLoaderData() as { quote : Quote }

. passar mensagem de retorno de error em quoteObj() de acordo com o error apresentado

. passar no return json   errors:  quoteObj.error.flatten()

. criar um <LoaderDataType> type como uma interface e passar em useLoaderData

. criar uma nova interface de tipagem: inferSafeParserErrors<com genericos>

. criar um type ActionDtaType baseado no inferSafeParserErrors e usar em useActionData 


ORGANIZANDO

. criar models/Quote.ts e colocar as tipagem lá em seguida importar de volta pra $id.tsx

INDEX.TSX
.passar validation CREATE, passar o  safeParse() e a condicional  pra mostrar erro ou pra criar

.estanciar o useActionData()

.criar o: type ActionDataType, e importar o errors: QuoteErrors, e tipar o useActionData<ActionDataType>()
